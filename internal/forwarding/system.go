// Copyright (c) 2018-2019, AT&T Intellectual Property. All rights reserved.
// SPDX-License-Identifier: GPL-2.0-only
package forwarding

import (
	"io"
	"os"
	"path/filepath"
	"regexp"
	"text/template"

	"github.com/danos/vci-service-dns/internal/fswatcher"
	"github.com/danos/vci-service-dns/internal/log"
	"github.com/danos/vci-service-dns/internal/process"
	"github.com/msoap/byline"
)

const systemFile = `### Autogenerated by vci-service-dns
### Note: Manual changes to this file will be lost during
###       the next commit.
{{range . -}}
server={{.}}	# system
{{end -}}
`

var systemFileTemplate *template.Template

func init() {
	t := template.New("SystemConf")
	t.Funcs(template.FuncMap{})
	systemFileTemplate = template.Must(t.Parse(systemFile))
}

type systemConfig struct {
	proc      process.Process
	watcher   *systemWatcher
	watchFile string
	confFile  string
}

func (c *systemConfig) removeConfFile() {
	err := os.Remove(c.confFile)
	if err != nil {
		log.Dlog.Println("system-config", err)
	}
}

func (c *systemConfig) Set(system bool) error {
	if !system {
		c.watcher.stop()
		c.removeConfFile()
		c.watcher = nil
	} else {
		c.watcher.stop()
		c.removeConfFile()
		c.watcher = startSystemWatcher(c.proc, c.confFile, c.watchFile)
	}
	return nil
}

// This would be better done by listening for a notification on VCI.
// TODO: implement this notification in system name-server component and switch this
//       to use it.
type systemWatcher struct {
	proc      process.Process
	watcher   *fswatcher.Watcher
	confFile  string
	watchFile string
}

func startSystemWatcher(proc process.Process, confFile, watchFile string) *systemWatcher {
	out := &systemWatcher{
		proc:      proc,
		confFile:  confFile,
		watchFile: watchFile,
	}
	if _, err := os.Stat(watchFile); err == nil {
		err := out.writeConffileFromResolv(watchFile)
		if err != nil {
			log.Dlog.Println("system nameserver watcher:", err)
		}
	}
	out.watcher = fswatcher.Start(
		fswatcher.LogPrefix("system nameserver watcher:"),
		fswatcher.Logger(log.Dlog),
		fswatcher.Handler(filepath.Dir(watchFile), nil),
		fswatcher.Handler(watchFile, out),
	)
	return out
}

func (w *systemWatcher) writeConffileFromResolv(resolv string) error {
	f, err := os.Open(resolv)
	if err != nil {
		return err
	}
	defer f.Close()

	out, err := os.OpenFile(w.confFile, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer out.Close()

	err = writeDnsmasqSystemConfig(out, readSystemNameservers(f))
	if err != nil {
		return err
	}
	return nil
}

func (w *systemWatcher) createOrWrite(name string) error {
	err := w.writeConffileFromResolv(name)
	if err != nil {
		return err
	}
	return w.proc.Reload()
}

func (w *systemWatcher) Write(name string) error {
	return w.createOrWrite(name)
}

func (w *systemWatcher) Create(name string) error {
	return w.createOrWrite(name)
}

func (w *systemWatcher) stop() {
	if w == nil {
		return
	}
	w.watcher.Stop()
}

func writeDnsmasqSystemConfig(w io.Writer, ns []string) error {
	if len(ns) == 0 {
		return nil
	}
	return systemFileTemplate.Execute(w, ns)
}

func readSystemNameservers(r io.Reader) []string {
	var ns []string
	err := byline.NewReader(r).
		GrepByRegexp(regexp.MustCompile("# system added by vyatta-system-nameservers")).
		AWKMode(func(line string, fields []string, vars byline.AWKVars) (string, error) {
			ns = append(ns, fields[1])
			return "", nil
		}).
		Discard()
	if err != nil {
		log.Wlog.Println("read-system-nameservers:", err)
	}
	return ns
}
