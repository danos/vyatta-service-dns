// Copyright (c) 2018-2019, AT&T Intellectual Property. All rights reserved.
// SPDX-License-Identifier: GPL-2.0-only
package dynamic

import (
	"bytes"
	"io/ioutil"
	"os"
	"reflect"
	"syscall"
	"testing"
	"text/template"
	"time"

	"github.com/danos/vyatta-service-dns/internal/process"
)

// This is a long timeout to account for slow build workers.
const testTimeout = 10 * time.Second

func init() {
	//For testing override the Date function in the cfgFileTemplate
	cfgFileTemplate.Funcs(template.FuncMap{
		"MapServiceName": mapServiceNames,
		"Date": func() string {
			return "Tue Nov 10 23:00:00 UTC 2009"
		},
	})
}

func TestWriteConfig(t *testing.T) {
	var buf bytes.Buffer
	conf := &InterfaceConfigData{
		Name: "dp0o1",
		Service: []ServiceConfigData{
			{
				Name:     "dyndns",
				HostName: []string{"foo.example.com"},
				Login:    "user",
				Password: "password",
			},
		},
	}

	const expected = `#
# autogenerated by vci-service-dns on Tue Nov 10 23:00:00 UTC 2009
#
daemon=1m
syslog=yes
ssl=yes
pid=/var/run/ddclient/ddclient_dp0o1.pid
cache=/var/cache/ddclient/ddclient_dp0o1.cache
use=if, if=dp0o1


protocol=dyndns2
max-interval=28d
login=user
password=password
foo.example.com

`
	err := writeConfig(&buf,
		"/var/cache/ddclient/ddclient_dp0o1.cache",
		"/var/run/ddclient/ddclient_dp0o1.pid",
		conf)
	if err != nil {
		t.Fatal(err)
	}
	if buf.String() != expected {
		t.Log("got", buf.String())
		t.Log("expected", expected)
		t.Fatal("didn't get expected output")
	}
}

type tproc struct {
	actions  chan string
	confFile string

	conf string
}

func newTproc(confFile string) *tproc {
	return &tproc{
		confFile: confFile,
		actions:  make(chan string, 1),
	}
}

func (p *tproc) Start() error {
	return nil
}
func (p *tproc) Stop() error {
	p.actions <- "stop"
	return nil
}
func (p *tproc) Reload() error {
	buf, err := ioutil.ReadFile(p.confFile)
	p.conf = string(buf)
	p.actions <- "reload"
	return err
}
func (p *tproc) Restart() error {
	return nil
}
func (p *tproc) Signal(signal syscall.Signal) error {
	return nil
}

func TestWriteEnv(t *testing.T) {
	var buf bytes.Buffer
	const expected = `#
# autogenerated by vci-service-dns
#
DDCLIENT_VRF_NAME=default
DDCLIENT_IF_CONF=/etc/ddclient/ddclient_dp0o1.conf
`
	err := writeEnvFile(&buf, "default",
		"/etc/ddclient/ddclient_dp0o1.conf")
	if err != nil {
		t.Fatal(err)
	}
	if buf.String() != expected {
		t.Log("got", buf.String())
		t.Log("expected", expected)
		t.Fatal("didn't get expected output")
	}
}

func TestConfigSet(t *testing.T) {
	defer func() {
		os.RemoveAll("tmp")
	}()
	config := NewConfig(
		DDClientRunDir("tmp/run"),
		DDClientCacheDir("tmp/cache"),
		DDClientConfigDir("tmp/config"),
		DDClientEnvDirFmt("tmp/run/%s"),
	)
	proc := newTproc("tmp/config/ddclient_dp0o1.conf")
	proc2 := newTproc("tmp/config/ddclient_dp0o2.conf")
	config.pCons = func(unit string) process.Process {
		switch unit {
		case "ddclient@dp0o1.service":
			return proc
		case "ddclient@dp0o2.service":
			return proc2
		default:
			t.Fatal("unexpected unit", unit)
			return nil
		}
	}
	cd := &ConfigData{
		Interface: []InterfaceConfigData{
			{
				Name: "dp0o1",
				Service: []ServiceConfigData{
					{
						Name:     "dyndns",
						HostName: []string{"foo.example.com"},
						Login:    "user",
						Password: "password",
					},
					{
						Name:     "dslreports",
						HostName: []string{"foo2.example.com"},
						Login:    "user1",
						Password: "password123",
					},
				},
			},
			{
				Name: "dp0o2",
				Service: []ServiceConfigData{
					{
						Name:     "dyndns",
						HostName: []string{"foo3.example.com"},
						Login:    "user",
						Password: "password",
					},
					{
						Name:     "zoneedit",
						HostName: []string{"foo4.example.com"},
						Login:    "user1",
						Password: "password123",
					},
				},
			},
		},
	}
	err := config.Set(cd)
	if err != nil {
		t.Fatal(err)
	}

	select {
	case act := <-proc.actions:
		if act != "reload" {
			t.Fatalf("reload expected, got %s", act)
		}
	case <-time.After(testTimeout):
		t.Fatal("timeout waiting for reload signal")
	}

	select {
	case act := <-proc2.actions:
		if act != "reload" {
			t.Fatalf("reload expected, got %s", act)
		}
	case <-time.After(testTimeout):
		t.Fatal("timeout waiting for reload signal")
	}

	const expected1 = `#
# autogenerated by vci-service-dns on Tue Nov 10 23:00:00 UTC 2009
#
daemon=1m
syslog=yes
ssl=yes
pid=tmp/run/ddclient_dp0o1.pid
cache=tmp/cache/ddclient_dp0o1.cache
use=if, if=dp0o1


protocol=dyndns2
max-interval=28d
login=user
password=password
foo.example.com

protocol=dslreports1
max-interval=28d
login=user1
password=password123
foo2.example.com

`
	const expected2 = `#
# autogenerated by vci-service-dns on Tue Nov 10 23:00:00 UTC 2009
#
daemon=1m
syslog=yes
ssl=yes
pid=tmp/run/ddclient_dp0o2.pid
cache=tmp/cache/ddclient_dp0o2.cache
use=if, if=dp0o2


protocol=dyndns2
max-interval=28d
login=user
password=password
foo3.example.com

protocol=zoneedit1
max-interval=28d
login=user1
password=password123
foo4.example.com

`
	if proc.conf != expected1 {
		t.Log("got", proc.conf)
		t.Log("expected", expected1)
		t.Fatal("didn't get expected output")
	}
	if proc2.conf != expected2 {
		t.Log("got", proc.conf)
		t.Log("expected", expected2)
		t.Fatal("didn't get expected output")
	}

	_, err = os.Stat("tmp/run/dp0o1/ddclient.env")
	if err != nil {
		t.Fatal(err)
	}
	_, err = os.Stat("tmp/run/dp0o2/ddclient.env")
	if err != nil {
		t.Fatal(err)
	}

	_, err = os.Stat("tmp/run")
	if err != nil {
		t.Fatal(err)
	}

	_, err = os.Stat("tmp/cache")
	if err != nil {
		t.Fatal(err)
	}

	err = config.Set(nil)
	if err != nil {
		t.Fatal(err)
	}

	select {
	case act := <-proc.actions:
		if act != "stop" {
			t.Fatalf("stop expected, got %s", act)
		}
	case <-time.After(testTimeout):
		t.Fatal("timeout waiting for reload signal")
	}

	select {
	case act := <-proc2.actions:
		if act != "stop" {
			t.Fatalf("stop expected, got %s", act)
		}
	case <-time.After(testTimeout):
		t.Fatal("timeout waiting for reload signal")
	}

	_, err = os.Stat("tmp/run/dp0o1/ddclient.env")
	if !os.IsNotExist(err) {
		t.Fatal(err)
	}
	_, err = os.Stat("tmp/run/dp0o2/ddclient.env")
	if !os.IsNotExist(err) {
		t.Fatal(err)
	}
	_, err = os.Stat("tmp/conf/ddclient_dp0o1.conf")
	if !os.IsNotExist(err) {
		t.Fatal(err)
	}
	_, err = os.Stat("tmp/conf/ddclient_dp0o2.conf")
	if !os.IsNotExist(err) {
		t.Fatal(err)
	}
	_, err = os.Stat("tmp/run")
	if !os.IsNotExist(err) {
		t.Fatal(err)
	}

	_, err = os.Stat("tmp/cache")
	if !os.IsNotExist(err) {
		t.Fatal(err)
	}

}

func TestConfigGet(t *testing.T) {
	defer func() {
		os.RemoveAll("tmp")
	}()
	config := NewConfig(
		DDClientRunDir("tmp"),
		DDClientCacheDir("tmp"),
		DDClientConfigDir("tmp"),
		DDClientEnvDirFmt("tmp/%s"),
	)
	proc := newTproc("tmp/ddclient_dp0o1.conf")
	proc2 := newTproc("tmp/ddclient_dp0o2.conf")
	config.pCons = func(unit string) process.Process {
		switch unit {
		case "ddclient@dp0o1.service":
			return proc
		case "ddclient@dp0o2.service":
			return proc2
		default:
			t.Fatal("unexpected unit", unit)
			return nil
		}
	}
	cd := &ConfigData{
		Interface: []InterfaceConfigData{
			{
				Name: "dp0o1",
				Service: []ServiceConfigData{
					{
						Name:     "dyndns",
						HostName: []string{"foo.example.com"},
						Login:    "user",
						Password: "password",
					},
					{
						Name:     "dslreports",
						HostName: []string{"foo2.example.com"},
						Login:    "user1",
						Password: "password123",
					},
				},
			},
		},
	}
	err := config.Set(cd)
	if err != nil {
		t.Fatal(err)
	}
	new := config.Get()
	if !reflect.DeepEqual(new, cd) {
		t.Log("got", new)
		t.Log("expected", cd)
		t.Fatal("didn't get expected result")
	}
}

func TestConfigUpdate(t *testing.T) {
	defer func() {
		os.RemoveAll("tmp")
	}()
	config := NewConfig(
		DDClientRunDir("tmp"),
		DDClientCacheDir("tmp"),
		DDClientConfigDir("tmp"),
		DDClientEnvDirFmt("tmp/%s"),
	)
	proc := newTproc("tmp/ddclient_dp0o1.conf")
	proc2 := newTproc("tmp/ddclient_dp0o2.conf")
	config.pCons = func(unit string) process.Process {
		switch unit {
		case "ddclient@dp0o1.service":
			return proc
		case "ddclient@dp0o2.service":
			return proc2
		default:
			t.Fatal("unexpected unit", unit)
			return nil
		}
	}
	cd := &ConfigData{
		Interface: []InterfaceConfigData{
			{
				Name: "dp0o1",
				Service: []ServiceConfigData{
					{
						Name:     "dyndns",
						HostName: []string{"foo.example.com"},
						Login:    "user",
						Password: "password",
					},
					{
						Name:     "dslreports",
						HostName: []string{"foo2.example.com"},
						Login:    "user1",
						Password: "password123",
					},
				},
			},
			{
				Name: "dp0o2",
				Service: []ServiceConfigData{
					{
						Name:     "dyndns",
						HostName: []string{"foo3.example.com"},
						Login:    "user",
						Password: "password",
					},
					{
						Name:     "zoneedit",
						HostName: []string{"foo4.example.com"},
						Login:    "user1",
						Password: "password123",
					},
				},
			},
		},
	}
	err := config.Set(cd)
	if err != nil {
		t.Fatal(err)
	}

	select {
	case act := <-proc.actions:
		if act != "reload" {
			t.Fatalf("reload expected, got %s", act)
		}
	case <-time.After(testTimeout):
		t.Fatal("timeout waiting for reload signal")
	}

	select {
	case act := <-proc2.actions:
		if act != "reload" {
			t.Fatalf("reload expected, got %s", act)
		}
	case <-time.After(testTimeout):
		t.Fatal("timeout waiting for reload signal")
	}
	_, err = os.Stat("tmp/dp0o1/ddclient.env")
	if err != nil {
		t.Fatal(err)
	}
	_, err = os.Stat("tmp/dp0o2/ddclient.env")
	if err != nil {
		t.Fatal(err)
	}
	new := &ConfigData{
		Interface: []InterfaceConfigData{
			{
				Name: "dp0o1",
				Service: []ServiceConfigData{
					{
						Name:     "dyndns",
						HostName: []string{"foo.example.com"},
						Login:    "user",
						Password: "password",
					},
				},
			},
		},
	}
	err = config.Set(new)
	if err != nil {
		t.Fatal(err)
	}

	select {
	case act := <-proc.actions:
		if act != "reload" {
			t.Fatalf("stop expected, got %s", act)
		}
	case <-time.After(testTimeout):
		t.Fatal("timeout waiting for reload signal")
	}

	select {
	case act := <-proc2.actions:
		if act != "stop" {
			t.Fatalf("stop expected, got %s", act)
		}
	case <-time.After(testTimeout):
		t.Fatal("timeout waiting for reload signal")
	}

	_, err = os.Stat("tmp/dp0o2/ddclient.env")
	if !os.IsNotExist(err) {
		t.Fatal(err)
	}
	_, err = os.Stat("tmp/ddclient_dp0o2.conf")
	if !os.IsNotExist(err) {
		t.Fatal(err)
	}
	const expected = `#
# autogenerated by vci-service-dns on Tue Nov 10 23:00:00 UTC 2009
#
daemon=1m
syslog=yes
ssl=yes
pid=tmp/ddclient_dp0o1.pid
cache=tmp/ddclient_dp0o1.cache
use=if, if=dp0o1


protocol=dyndns2
max-interval=28d
login=user
password=password
foo.example.com

`
	if proc.conf != expected {
		t.Log("got", proc.conf)
		t.Log("expected", expected)
		t.Fatal("didn't get expected output")
	}
	_, err = os.Stat("tmp/dp0o1/ddclient.env")
	if err != nil {
		t.Fatal(err)
	}
}
